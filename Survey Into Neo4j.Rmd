---
title: "Load Neo4j Database from 2017 October Survey for DFO Salmon Network"
author: "Scott Akenhead scott@s4s.com 1-250-210-4410"
date: '`r format(Sys.Date(),"%Y %B %d")`'
output:
  html_notebook: 
    highlight: pygments
    number_sections: yes
    theme: journal
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
library(jsonlite, quietly=T);
library(knitr, quietly=T);
library(ggplot2, quietly=T); 
library(magrittr, quietly=T);
library(googlesheets, quietly=T);
library(openssl, quietly=T);
library(visNetwork, quietly=T); 
library(RNeo4j, quietly=T);  # note caps

knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	comment = "",
	results = "hold")
options(digits=5, show.error.locations=T, stringsAsFactors=F);
```

# Introduction
The 2017 October survey of DFO salmon staff were previously edited and unpacked into .csv tables via R notebook *Survey as Sheets Into R.Rmd*. The objectives of this R notebook are  
(a) tables in JSON format for version 0.0 of RoundTable^tm^,  
(b) a neo4j database for version 0.1 of RoundTable, and  
(d) a neo4j database for visuals via R package *networkviz*.

For an example of the Cypher queries to load neo4j from those tables, a **Person** name "x" and an **Activity** name "z" from PersonHasActivity are applied as
> CREATE (:Person{name:"x", ID:1}) -[hasActivity{type:"y", ID:2}]->
 (:Activity{name:"z",type:"",description:"", ID:3})

The "Resources" collected were **Person, IdeaTag, Organizaiton, Site (has Address, Place does not, Location is defunct), Address, and Activity**. Links between these are two-way in RoundTable (only one-way links are created in neo4j, but can then be treated as bi-directional or independent of direction).  **PersonHasOrg** is equivalent to **OrgHasPerson**. The possible links are in the following table. Edge types are implied and subTypes are not specified. Not all links are required: a **Site** may or may not not have a **ContactService.** Some are not advised: **Address** is not needed for **Person, Activity**, and **Org** because these should have at least one place **Site** with an **Address**.

|Resource|Person|Activity|Org. |Site |address|conServ.|IdeaTag|
|:-------|:----:|:------:|:---:|:---:|:-----:|:------:|:-----:|
|Person  |PP|PA|PO|PS|- |Pc|PI|
|Activity|- |AA|AO|AS|- |Ac|AI|
|Org.    |- |- |OO|OS|Oa|Oc|OI|
|Site    |- |- |- |- |Sa|Sc|SI|
|IdeaTag |- |- |- |- |- |- |II|


This leaves out **WorkGroup**, to be added via RoundTable because (a) security features, fields, and links (**isVisibleTo**) are invoked via **WorkGroup**, and (b) a **Workgroup** involve personal responsiblity that needs formal acceptance not accidental imposition. Further Resources not yet included: **Doc, Citation, Data, Metadata, Maps, Models, Conversation, Entry, Item, and Request.** Their inclusion creates more edge types (node-link-node combinations).

Some Resources are non-strict hierarchies, such as **Place:** where 'Departure Bay' is in 'Strait of Georgia' is in 'Pacific Ocean'. Thus 'Departure Bay' should not be directly linked 'British Columbia' but could have **IdeaTag**{name:"British Columbia"}. That is, a **Place** may be similar to an **Idea** (political jurisdiction), and there is no problem about using the same name in two different Resources.

## Local Functions
An effort is made to co-locate the functions used in the subsequent R code. This facilitates a possible R package to assist others with similar work.

```{r local, echo=T}
cat("working directory:",getwd(),"\n");
# rip up your guy before this one: cardcol=c("skyblue","peachpuff","chartreuse", "seagreen") 

# my functions start with a capital; CamelCase. 
# my variables are pythonCase unless they are a Resource in RoundTable.

AddUID = function(a){
# add or update ID column in a data.frame (column name is not UID)
    last <- lastUID; # lastUID inherited from parent environment
    n <-  dim(a)[1];  
    a$ID <- seq.int(from=last+1,to=last+n, by=1)
    lastUID <<- last+n;  # changes lastUID in parent environment
    return(a);  # modified
# examples 
#   a <- AddUID(a)
#   a %<>% AddUID # maggritr pipe 
}

#Macro=function(txt) eval(parse(text=txt)); # execute text
#MakeUID=function(n=1){
#    make1=function() paste0(sample(c(LETTERS),9,replace=T),collapse='');
#    if (n == 1) return(make1());
#   uid=character(n)
#    for(j in 1:n) uid[j] <- make1()
#    return(uid)
#}

SampleRows <- function(a,caption=NA, nrows=10, ...){
    # prints a random sample of rows
    # you can pass "col.names" and other controls for kable().
    n1=dim(a)[1];    n2=min(nrows,n1)
    j <- sort(sample.int(n1,n2)) 
    kable(a[j, ], caption=caption,...); # keeps row number
}
```

# Read Data Extracted from Survey
Some .csv files were edited as Google Sheets.
```{r}
getwd()
fs <- list.files("../output")
for (f in fs){
    obj <- f %>% strsplit(".", fixed=T) %>% unlist %>% `[`(1) # "Activity"
    cat(obj)
    f.in = paste0("../output/", obj,".csv")
    if (!file.exists(f.in)) stop(" file does not exist")
    read.csv(f.in) %>% `[`(,-1) %>% assign(obj,.) # drop row numbers
    cat("  ", dim(get(obj)), "\n  ",colnames(get(obj)),"\n")
}
```
## Tidying
```{r}
## remove Conley Kevin (a duplicate of Kevin Conley)
#PersonHasContactService <- PersonHasContactService[-82,]
#Person <- Person[-82,]
```

# Fields conform to RoundTable
RoundTable has many conventions. However, many are arbitrary such as what names are capitalized; I wanted Resources to be capitals (and bold in text): **Person, Place, Activity**,, and field names to be pythonCase (and italic for text): *label, title, startDate, nameString, lastName*,. Should *familyname* be *lastName*?  The database convention of avoiding plural should be followed.
Data loading will conform. Resistance is futile.

## Sequential ID
A unique identity field (ID, not uid) is added to each node and link. This can be approached as  
1. an unlikely-to-be-duplicated numeric field (say 32 bytes, so >1 in 10 trillion billion chance of a duplicate from 10 million nodes and links),  
2. as sequential uids from abitrary starts (which means the starts must be known), or  
3. uid are create from field names or combinations known to be unique: email, name + personal phone, latitude + longitude,.
We will use method 2 in what follows, incrementing with every use a variable called *lastUID*. This is applied to a dataframe *a* by local function *AddUID* as 
> a %<>% AddUID 

```{r lastUID}
lastUID = 0  # the start. Please be careful with this.
```

## Codes for Resource Type
Edges are specified internally by three numeric codes (from, link, to) rather than by English words. This is partly to enable localization.  
### Resource codes
from roundtable_domain.js received 2018-05-07
>var resourceNodeTypeID_domain 			= 11199;
var resourceNodeTypeID_person 			= 11210;
...
var resourceNodeTypeID_other 			= 11233;

>11210 person, 11211 organization, 11212 workgroup, 11213 event,11214 activity, 11215 place, 11216 document, 11217 webpage, 11218 citation, 11219 media, 11220 map, 11221 dataset, 11222 model, 11223 address, 11224 contactService, 11225 entry, 11226 item, 11227 request, 11228 message, 11229 conversation, 11230 learningObject, 11231 metadata, 11232 site,11233 other

To this I have added **code 11234 for idea.**
Rationale: Idea or IdeaTag is a Resource, just another node. The link between two ideas, or between a resource and an idea is not different than between two resources.

The following code provide a function _resourceID_to relate resource name to resource code.
```{r}
hash.resource = data.frame(domain=11199,person=11210,organization=11211,workgroup=11212,event=11213,activity=11214,place=11215,document=11216,webpage=11217,citation=11218,media=11219,map=11220,dataset=11221,model=11222,address=11223,contactService=11224,entry=11225,item=11226,request=11227,message=11228,conversation=11229,learningObject=11230,metadata=11231,site=11232,other=11233, idea=11234);
resourceID = function(text) as.integer(hash.resource[text])
```

### Idea subTypes
>67000 taxonomy,67001 life_history,67002 research,67003 management,67004 
67005 geography, 67006 ecology,67007 biology,67008 other,67009 structure,67010 function,67011 IYS Theme

### Link Codes
>citedBy 21261, cites 21247,containedIn 21262, contains 21248, created 21231, createdBy 21260, hasActivity 21227, hasActivityParticipant 21267, hasActivityRole 21257, hasAddress 21219, hasCitation 21218 ,hasContactPerson 21259, hasContactService 21220, hasConversation 21236, hasDataset 21258, hasEntry 21237, hasEvent 21228, hasEventParticipant 21266, hasEventRole 21256, hasItem 21232, hasManager 21251, hasMedia, 21229, hasMessage 21241, hasMetadata 21249, hasOrganization 21226, hasOrganizationAffiliate 21265, hasOrganizationRole 21254, hasPlace 21238, hasRequest 21242, hasResponse 21250, hasSeen 21235, hasUser 21252, hasWebpage 21217, hasWorkgroup 21221, hasWorkgroupMember 21264, hasWorkgroupRole 21255, inAddress 21268, isLinkedTo 21245, isRelatedTo 21243, isVisibleTo 21210, seenBy 21263, selected 21253

```{r ResourceLinkCodes}
RLcode<-read.csv("../data/RLcodeRT.csv");
cat("RLcode has",dim(RLcode)[1], "rows\n"); colnames(RLcode)
```

## Person
From roundtable_data.js:
>var persons_text = '{"persons": ['+ '{"ID": 6067182960,"label": "Chuck Parken","namestring":"Chuck Parken", "firstnamesorinitials":"Chuck", "familyname":"Parken", "description":"", "status":"active", "startdate":"2017 January 24", "enddate":"2017 January 26"},'+

From email 2018-04-21
>ID_no = person_json[i].ID;  # this is unique instance id
"ID": ID_no
"resourceNodeTypeID": 11210  
"resourceNodeSubTypeID": ''
"label": ""
"nameString": ""
"prefix": ""
"firstNamesOrInitials": ""
"middleNamesOrInitials": ""
"familyName": ""          # should be familyName
"familySuffix": ""
"honorificSuffix": ""
"description": ""
"status": "active"
"start_date": "",
"end_date": "",

### from RoundTable-Neo4j-SalmoSphere.net trials 2018 May 1
>var persons_text = '{"persons": ['+
'{"ID":367,"resourceNodeTypeID":'+resourceNodeTypeID_person+',"resourceNodeSubTypeID": "", "label":"Aaron Burgoyne","name":"","nameString":"Aaron Burgoyne","first_name":"Aaron","last_name":"Burgoyne", "description":"",     "status": "active", "start_date": "2017 January 24", "end_date": "2017 January 26"},'

9 base fields
ID, resourceNodeTypeID,resourceNodeSubTypeID,
label,name,description,
status:,start_date:,end_date

special fields
nameString, first_name,last_name


```{r p}
file="../output/queries.txt"
n <- 4
basicField <- c("ID","resourceNodeTypeID",
"resourceNodeSubTypeID","label","name","description",
"status","start_date","end_date");
specialField <-c("nameString","first_name","last_name")
field<- c(basicField, specialField)
nc<- length(field)
b <- data.frame(t(character(nc))) ;
colnames(b) <- c(field)
b[1:n,1:9] <- list(NA,resourceID("person"),NA,
    Person$Person.name[1:n], Person$Person.name[1:n],"",
    "active","2017-01-24","");
b[,10:12]<- list(
    Person$Person.name[1:n],
    Person$Person.firstName[1:n],
    Person$Person.lastName[1:n])
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

i=1:12; 
paste0(':"\',b[j,',i,'],\'",') %>% paste0(field,.) %>%cat(sep="");
#ID:"',b[j,1],'",resourceNodeTypeID:"',b[j,2],'",resourceNodeSubTypeID:"',b[j,3],'",label:"',b[j,4],'",name:"',b[j,5],'",description:"',b[j,6],'",status:"',b[j,7],'",start_date:"',b[j,8],'",end_date:"',b[j,9],'",nameString:"',b[j,10],'",first_name:"',b[j,11],'",last_name:"',b[j,12],'",

for(j in 2:n){
    query <- paste0('CREATE (:Person{
ID:"',b[j,1],'",resourceNodeTypeID:"',b[j,2],'",resourceNodeSubTypeID:"',b[j,3],'",label:"',b[j,4],'",name:"',b[j,5],'",description:"',b[j,6],'",status:"',b[j,7],'",start_date:"',b[j,8],'",end_date:"',b[j,9],'",nameString:"',b[j,10],'",first_name:"',b[j,11],'",last_name:"',b[j,12],'"})' );
    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}

```

## Idea
The data in IdeaTagA needs hand editing because of duplicates and synonyms. That requires changing PersonHasIdeaTag to maintain correspondence.

```{r idea}
d=a=IdeaTagA[order(IdeaTagA$name),]
a=rbind(a,c("xyz","abc")) # extra row. hacking.
k=0
for(j in 2:dim(a)[1]){
    if(a$name[j-1] =="") next # a name is blank
    if(a$name[j] == a$name[j-1]){ # duplicated name?
        if(is.na(a$description[j]))
            a$description[j]<-a$description[j-1];
        next; }
    k %<>%I; d[k,] <- a[j-1,]
}
d <-d[1:k,]
```
### Idea subTypes
>67000 taxonomy,67001 life_history,67002 research,67003 management,67004 
67005 geography, 67006 ecology,67007 biology,67008 other,67009 structure,67010 function,67011 IYS Theme

### Idea create
There are no special fields for Idea; just the 9 basic fields.

```{r i.q}
b <- data.frame(t(character(9))) ;
colnames(b) <- c(basicField)
b[1:n,1:9] <- list(NA,resourceID("idea"),NA,
PersonHasIdeaTagB$IdeaTag.name[1:n],PersonHasIdeaTagB$IdeaTag.name[1:n],PersonHasIdeaTagB$IdeaTag.description[1:n],
"active","2017-01-24","");
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:Idea{ID:"', b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],'", label:"',b[j,4],'", name:"',b[j,5],'",description:"',b[j,6],'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```

## ContactService
received 2018-05-09
> var obj_contactServices = {"contactServices": [{ "ID": 618, "resourceNodeTypeID":11224, "resourceNodeSubTypeID": 420000,  "label": "Aaron Burgoyne", "name": "Aaron Burgoyne",  "description": "", "start_date": "", "end_date": "", "status": "active" "contactServiceString": "Aaron.Burgoyne@dfo-mpo.gc.ca"},

special field:  _contactServiceString_ for the URLs, phone numbers, and emails. This is decoded: a phone number with a country code, city code, and number.

Scott Carley thinks the label for ContactService should be a Person label. Redundant, but allows error detection. The edge (P)-[]->(C) would have a subtype that is the same as the type for ContactService. Tighter in a subsequent version. 

Some subtype names and codes are required. How about:  
1 emailWork
2 emailPersonal
3 phoneWork
4 phonePersonal
5 phoneOther
6 socialMedia - no need for individual subtypes, covered in Label and Description, the latter containing the URL, etc.
7 collaboration - for work, e.g. Slack, GitHub,. see 6. 

```{r c.email}
b <- data.frame(t(character(10))) ;
colnames(b) <- c(basicField,"contactServiceString")
b[1:n,1:10] <- list(
    NA,resourceID("contactService"),1,
    PersonHasContactService$Person.name[1:n], "", "",
    "active","2017-01-24","",
    PersonHasContactService$emailWork[1:n]);
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:ContactService{ID:"', b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],'", label:"',b[j,4],'", name:"',b[j,5],'",description:"',b[j,6],'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9], '",contactServiceString:"',b[j,10],'"})' );

#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```
```{r c.phone}
b <- data.frame(t(character(10))) ;
colnames(b) <- c(basicField,"contactServiceString")
b[1:n,1:10] <- list(
    NA,resourceID("contactService"),3,
    PersonHasContactService$Person.name[1:n], "", "",
    "active","2017-01-24","",
    PersonHasContactService$phoneWork[1:n]);
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:ContactService{ID:"', b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],'", label:"',b[j,4],'", name:"',b[j,5],'",description:"',b[j,6],'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9], '",contactServiceString:"',b[j,10],'"})' );

#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```

## Activity
From roundtable_data.js:
>var activities_text = '{"activities": ['+'{"ID": 24011,"label": "International", "name": "International", "description_long": "An intensive burst", "activityType": "program", "status": "active", "startdate": "dfadfa", "enddate": "fdafdadf" },'+

Reconciling these names with basic names: description_long is description, activityType is resourceNodeSubTypeID. 

```{r a}
b <- data.frame(t(character(9))) ;
colnames(b) <- c(basicField)
b[1:n,1:9] <- list(NA,resourceID("activity"),1,
Activity$Activity.name[1:n],Activity$Activity.name[1:n], Activity$Activity.description[1:n],
"active","2017-01-24","");
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:Activity{ID:"', b[j,1],
'", resourceNodeTypeID:"',b[j,2],
'", resourceNodeSubTypeID:"',b[j,3],
'", label:"',b[j,4],'", name:"',b[j,5],'", description:"',b[j,6],
'", status:"',b[j,7],'",start_date:"',b[j,8],
'",end_date:"',b[j,9],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```

## Organization
field for description is missing from RT
organizationtype should be organizationType
From roundtable_data.js:
> var organizations_text = '{"organizations": ['+'{"ID": 3901, "label":"Institute of Ocean Sciences", "name": "Institute of Ocean Sciences", "acronym":"IOS", "organizationtype": "federal research", "status":"active", "startdate":"2017 January 24", "enddate":"2017 January 26"},'+

special names: acronym. 
Is "PBS" an acronym or initials? 

note: OrgHasOrg$fromOrg.name but we will start with PersonHasOrg.
Redundancy requires MERGE instead of CREATE.

```{r o}
b <- data.frame(t(character(10))) ;
colnames(b) <- c(basicField,"acronym")
b[1:n,1:10] <- list(NA,resourceID("organization"),1,
PersonHasOrg$Org.name[1:n],PersonHasOrg$Org.name[1:n],"",
"active","2017-01-24","",
"");
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('MERGE (:Activity{ID:"', b[j,1],
'", resourceNodeTypeID:"',b[j,2],
'", resourceNodeSubTypeID:"',b[j,3],
'", label:"',b[j,4],'", name:"',b[j,5],'", description:"',b[j,6],
'", status:"',b[j,7],'",start_date:"',b[j,8],
'",end_date:"',b[j,9],
'",acronym:"',b[j,10],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}

```

## WebPage
From roundtable_data.js:
>var webpages_text = '{"webpages": ['+'{"ID": 21101,"label": "PBS Home Page", "name": "Pacific Biological Station Home Page",  "description": "main webpage for the Pacific Biological Station", "URL":"http://www.pac.dfo-mpo.gc.ca/science/facilities-installations/pbs-sbp/index-eng.html", "status": "active","webpagetype": "main", "createdDate": "2017 January 19", "modifiedDate": "2017 January 19" }'+

Special fields: URL, modifiedDate.  
_webPageType_ is taken to be subType. "Wikipedia" should be a subType.  An important role for hasWebPage is to declare the source of information, so that should be a subType (ditto for that edge)
Note resource name is all lower case: webpage not WebPage.  

How does one determine _modifiedDate_ for a web page? This is a famous gap in the definition of the WWW. This should probably be _accessedDate_ which is frequently used when citing a URL as the source of information.

Typically the data has multiple URLs in a list. Not dealt with in this code.  
Using data from ActivityHasWebPage where there is a mistake: column name IdeaTag.name should be URL.

```{r w}
b <- data.frame(t(character(11))) ;
colnames(b) <- c(basicField,"URL","modifiedDate")
b[1:n,] <- list(NA,resourceID("webpage"),1,
"","","",  "active","2017-01-24","", ActivityHasWebPage$IdeaTag.name[1:n],"") # URL, modifiedDate

b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:WebPage{ID:"', b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],
'", label:"',b[j,4],'",name:"', b[j,5], '", description:"',b[j,6],
'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9],
'",URL:"',b[j,10],'",modifiedDate:"',b[j,11],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```

## WorkGroup
From roundtable_data.js 2018-04-13
>'{"ID": 21001,"resourceNodeTypeID":'+resourceNodeTypeID_workgroup+',"resourceNodeSubTypeID": "'+resourceNodeSubTypeID_network+'", "label": "DFO Salmon Network", "name": "DFO Salmon Network",  "description": "salmon staff in DFO", "status": "active", "startdate": "2017 January 19", "enddate": "2020 January 19"},'+

spelling" 'workgroups' but used as 'workgroup" and should be 'workGroup.' 
_workgrouptype_ is taken to be subType.
There is no survey data for WorkGroup, so I used this:
“We, the unwilling, led by the unknowing, are doing the impossible for the ungrateful. We have done so much, for so long, with so little, we are now qualified to do anything with nothing.” ― Konstantin Jireček  

```{r wg}
testData <- c("We the Unwilling", "Led by the Unknowing", "Doing the Impossible","For the Ungrateful") 
b <- data.frame(t(character(9))) ;
colnames(b) <- c(basicField)
b[1:n,1:9] <- list(NA,resourceID("workgroup"),1,
testData,"","",
"active","2017-01-24","");
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:WorkGroup{ID:"', b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],
'", label:"',b[j,4],'",name:"', b[j,5], '", description:"',b[j,6],
'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```


## Place 
> var places_text = '{"places": ['+'{ "ID": 27000,"label": "Canada","name": "Canada","abbreviation":"","alpha2code":"CA", "alpha3code":"CAN", "numeric":"124","description": "","placetype": ,"altPlaceType":"","status": "active","geoJSONStringType": "Polygon", 	"geoJSONString": "", "source":"", "sourceurl":"" },'+

From roundtable_data.js 2018-04-13
>var places_text = '{"places": ['+ '{
"ID": ,"resourceNodeTypeID":,"resourceNodeSubTypeID":,  "label": ,   "name": , "abbreviation":, "alpha2code":, "alpha3code":, "numeric":,"description": "",    "altPlaceType":"", "status": , "geoJSONStringType": , "geoJSONString": "", "source":"", "sourceurl":

9 special names: abbreviation, alpha2code, alpha3code, numeric, altPlaceType, geoJSONStringType, geoJSONString, source, sourceurl

_placetype_ is redundant with subType.
_source_ and _sourceurl_ look like hasWebPage{subType:"source"}. sourceurl should be sourceURL.

```{r place}
specialField=c("abbreviation", "alpha2code", "alpha3code", "numeric","altPlaceType", "geoJSONStringType", "geoJSONString", "source", "sourceurl") # 9
field=c(basicField,specialField) # 18
i=1:18; 
paste0(':"\',b[j,',i,'],\'", ') %>% 
 paste0(field,.) %>% cat(sep="");
#ID:"',b[j,1],'",resourceNodeTypeID:"',b[j,2],'",resourceNodeSubTypeID:"',b[j,3],'",label:"',b[j,4],'",name:"',b[j,5],'",description:"',b[j,6],'",status:"',b[j,7],'",start_date:"',b[j,8],'",end_date:"',b[j,9],'",abbreviation:"',b[j,10],'",alpha2code:"',b[j,11],'",alpha3code:"',b[j,12],'",numeric:"',b[j,13],'",altPlaceType:"',b[j,14],'",geoJSONStringType:"',b[j,15],'",geoJSONString:"',b[j,16],'",source:"',b[j,17],'",sourceurl:"',b[j,18],'", 
PlaceHasAddress[1,"place"]
PlaceHasAddress[1,"latLong"]
b <- data.frame(t(character(18))) ;
colnames(b) <- field
b <- data.frame(NA, resourceID("place"),NA,
    PersonHasPlace$Place[1:n],"", "",
    status="active", startdate="2017-01-27", enddate="",
    "",NA,NA,NA,"","","","","");
b %<>% AddUID; cat("lastUID =",lastUID,"\n");

for(j in 1:n){
    query <- paste0('CREATE (:Place{ID:"',b[j,1],'", resourceNodeTypeID:"',b[j,2],'", resourceNodeSubTypeID:"',b[j,3],'", label:"',b[j,4],'", name:"',b[j,5],'", description:"',b[j,6],'", status:"',b[j,7],'", start_date:"',b[j,8],'", end_date:"',b[j,9],'", abbreviation:"',b[j,10],'", alpha2code:"',b[j,11],'", alpha3code:"',b[j,12],'", numeric:"',b[j,13],'", altPlaceType:"',b[j,14],'", geoJSONStringType:"',b[j,15],'", geoJSONString:"',b[j,16],'", source:"',b[j,17],'", sourceurl:"',b[j,18],'"})' );
#    cat(query,"\n", file=file, append=TRUE)
    cat(query,"\n") # echo
}
```
## Address
> var addresses_text = '{"addresses": ['+'{"ID": 29001,"label": "NAFC","name": "Northwest Atlantic Fisheries Centre ", "addressString": "80 East White Hills Road  St. John\'s, NL Canada A1A 5J7", "addressTypeID": 41000,"status": "active", "street": "80 East White Hills Road ","locality": 27014,"region": 27001, "country": 27000,"postalCode": "A1A 5J7", "geoJSONStringType":"point", "geoJSONString":"[longitude, latitude, elevation]" },'+ 

Should be address not addresses. addressTypeID is subType.
special fields: addressString, street, locality, region, country, postalCode,geoJSONStringType, geoJSONString.

but as of 2018-03-13
>var current_address_addressType ="";
var current_address_addressString= "";
var current_address_label ="";
var current_address_name ="";
var current_address_description ="";
var current_address_postOfficeBox ="";
var current_address_aptNumber ="";
var current_address_street= "";
var current_address_locality ="";
var current_address_region ="";
var current_address_country ="";
var current_address_postalCode ="";
var current_address_geoJSONStringType ="";
var current_address_geoJSONString ="";
var current_address_status ="";
var current_address_startDate ="";
var current_address_endDate ="";

"The addressString is parsed into its various parts if the user wants it. Just give the street  address as a string and there are routines to  parse it.  (Do need to pick out locality, region and country).  And these parse results can be edited by the user." JSC

Why is it "current address"? That is what {status, startdate, enddate} are for.  
Does region mean "state or province?". Does locale mean "city or town?" 
There will be pre-assigned numeric codes for Place that can be used within Address: country, province, addressTypeID,.

GIS stuff should be a separate Resource, to be used in MapView. Now GIS data is scattered across three Resources: place, address, dataset.  Typically latitude precedes longitude.

DFO Region is Org or Place (not Idea, not Address).

additional specialField: postOfficeBox, aptNumber

```{r address}
# not updated to 2018-03-13 standard
specialField=c("addressString", "street", "locality", "region", "country", "postalCode", "geoJSONStringType", "geoJSONString");
a= PlaceHasAddress$place
LL <- PlaceHasAddress$latLong
LL[is.na(LL)] <- "0, 0"
LL= paste0("[",LL,", 0]")
a <- PlaceHasAddress$place;
b <- data.frame(ID=NA, resourceID=11215, addressTypeID=NA,
    label=a, name=a, 
    addressString=NA,
    poBox=     PlaceHasAddress$poBox,
    street=    PlaceHasAddress$address,
    locality=  PlaceHasAddress$city,
    region=    PlaceHasAddress$province,
    country=   "Canada",
    postalCode=PlaceHasAddress$postalCode,
    geoJSONStringType="point",
    geoJSONString=LL,
    status="active", startdate=NA, enddate=NA);
b %<>% AddUID; cat("lastUID =",lastUID,"\n");
b %>% toJSON(pretty = TRUE) %>% cat(file=file);
```


## Event
> var events_text = '{"events": ['+'{"ID": 25001, "label": "DFO IYS Workshop Richmond January 2017", "name": "DFO IYS Workshop Richmond January 2017", "description": "DFO salmon scientists network","eventtype": "workshop","status": "active","startdate": "2017 January 24", "enddate": "2017 January 26"},'+	


```{r e}
# file <- "../data/Event.json"
# a <- $;
# b <- data.frame(ID=NA, resourceID=11213,eventtype=NA,
#     label=a, name=a, description=NA,
#     status="active", startdate=NA, enddate=NA);
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```

## Map
> var maps_text = '{"maps": ['+'{"ID": 1121307,"size": 20,"x": 6,"y": 109,"type": "map","label": "map label 2","name": "map name 2","maptype": "","status": "active","source": "Salish Sea Wiki","sourceurl": "http://salishseatrust.ca"}'+

```{r map}
# file <- "../data/Map.json"
# a <- $;
# b <- data.frame(ID=NA, resourceID=11220,type=NA,
#     label=a, name=a, description=NA,
#     source=NA,sourceurl=NA,
#     status="active", startdate=NA, enddate=NA);
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```
## Doc
>var documents_text = '{"documents": ['+'{ "ID": 22001, 	"label":"A Departmental Salmon Network", "name": "A Departmental Salmon Network with Reference to the International Year of the Salmon", "description": "Draft Terms of Reference","format": ".docx","citation_string": "2017 January 19", "createdDate":"E JAN 01 2017", "modifiedDate":"E FEB 28 2017"},'+

Looks like RoundTable does not follow ISO6801 for dates, but should.

```{r doc}
# file <- "../data/Doc.json"
# a <- $x ;
# b <- data.frame(ID=NA, resourceID=11216,type=NA,
#     label=a, name=a, description=NA,
#     format=NA,citation_string=NA,
#      status="active", createdDate=NA, modifiedDate=NA);
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```

## MetaData
>var metadata_text = '{"metadata": ['+'{"ID": 23601,"label": "label for metadata 1", "title": "title of metadata 1", "description":"description for metadata 1", "metadataStandardID":411100, "metadataString": "hlkhlkafhsl", "status":"active",  "createdDate":"E JAN 01 2017", "modifiedDate":"E FEB 28 2017"},'+

```{r meta}
# file <- "../data/MetaData.json"
# a <- $x ;
# b <- data.frame(ID=NA,resourceID=11231,type=NA,
#    label=NA,title=NA,description=NA,
#    metadataStandardID=NA, metadataString=NA,
#    status=NA, createdDate=NA, modifiedDat=NA)
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```

## Media
>var media_text = '{"media": ['+'{"ID": 112001,"size": 20, "x": 6,"y": 2,"type": "media", "label": "media label 1","name": "media name 1", "mediaType": "text", "mediaSubType": "MSword","status": "active","source": "Salish Sea Wiki","sourceurl": "https://salishsearestoration.org/wiki/Workgroups"},'+  

```{r media}
# file <- "../data/Media.json"
# a <- $x ;
# b <- data.frame(ID=NA,resourceID=11219,type=NA,
#     label=NA,title=NA,description=NA,
#     size=NA,mediaTYpe=NA,mediaSubType=NA,
#     source=NA,sourceurl=NA,
#     status=NA, createdDate=NA, modifiedDate=NA)
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```

## Model 
> var models_text = '{"models": ['+'{ "ID": 112132,"size": 20, "x": 6, "y": 109, "type": "model","label": "model label 2", "name": "model name 2", "modeltype": "", "status": "active","source": "Salish Sea Wiki", "sourceurl": "http://salishseatrust.ca" }'+']}';

```{r model}
# file <- "../data/Model.json"
# a <- $x ;
# b <- data.frame(ID=NA,resourceID=11222,type=NA,
#     size=NA,x=NA,y=NA,type=NA,source=NA, sourceurl=NA)
#     status=NA, createdDate=NA, modifiedDate=NA)
# b %<>% AddUID; cat("lastUID =",lastUID,"\n");
# b %>% toJSON(pretty = TRUE) %>% cat(file=file)
```

# Links
Links are (impossibly) constrained to pre-specified sub-types in RT, and are expressed by UID and numeric codes for link type and numeric codes for nodes (Resources). External data loading is thereby complicated, where 'complicated' means prone to bugs.

**isRelatedTo** is used for all X-hasX-X, as opposed to Person -hasPerson-Person.


>var isRelatedToEdges_text = '{"isRelatedToEdges": ['+'{ "ID": 76001, "fromResourceNodeID":"6067182960", "fromResourceNodeTypeID":'+resourceNodeTypeID_person+', "fromResourceNodeSubTypeID":"", "toResourceNodeID":"6064932323", "toResourceNodeTypeID":'+resourceNodeTypeID_person+', "toResourceNodeSubTypeID":"", "linkTypeID":'+resourceLinkTypeID_isRelatedTo+', 	"linkSubTypeID":'+resourceLinkSubTypeID_worksWith+', "label":"worksWith", "name":"works with", "description": "on Fraser Chinook-Coho stock assessment",  "status": "active", "isPrimary":"yes",  "startDate":"", "endDate":"" },'+ 

Note: if nodes have IDs, as in *fromResourceNodeID* then *fromResourceNodeTypeID* and *fromResourceNodeSubTypeID* should be available from that node. Why are these not in the original node specification? I added them. I have not added the IDs for Resource subtype, as in (:Resource{typeID:543})

```{r linkCode}
a <- scan( file("stdin"),what=c("a",1),strip.white=TRUE)
citedBy 21261
cites 21247
containedIn 21262
contains 21248
created 21231
createdBy 21260
hasActivity 21227
hasActivityParticipant 21267
hasActivityRole 21257
hasAddress 21219
hasCitation 21218
hasContactPerson 21259
hasContactService 21220
hasConversation 21236
hasDataset 21258
hasEntry 21237
hasEvent 21228
hasEventParticipant 21266
hasEventRole 21256
hasItem 21232
hasManager 21251
hasMedia 21229
hasMessage 21241
hasMetadata 21249
hasOrganization 21226
hasOrganizationAffiliate 21265
hasOrganizationRole 21254
hasPlace 21238
hasRequest 21242
hasResponse 21250
hasSeen 21235
hasUser 21252
hasWebpage 21217
hasWorkgroup 21221
hasWorkgroupMember 21264
hasWorkgroupRole 21255
inAddress 21268
isLinkedTo 21245
isRelatedTo 21243
isVisibleTo 21210
seenBy 21263
selected 21253

```


```{r P-P}
PersonHasPersonRT <- data.frame(
    ID=NA,linkTypeID=NA,
fromResourceNodeID=,
fromResourceNodeTypeID=,
fromResourceNodeSubTypeID=, 
toResourceNodeID=, 
toResourceNodeTypeID=,
toResourceNodeSubTypeID,
linkTypeID
linkSubTypeID=,
label="worksWith", name="works with", description=NA,
isPrimary="yes",
status= "active",startDate="2018-01-01", endDate=NA);
```



<- data.frame(name = PlaceHasAddress$place; description = NA, 
    latLong = PlaceHasAddress$latLong);
j = which(!is.na(PlaceHasAddress$photo)) # find photo URLs
a <- data.frame(Place.name[j],type="image",URL=PlaceHasAddress$photo[j]) 
j = which(!is.na(PlaceHasAddress$webPage));  # find description URLs
b <- data.frame(Place.name[j], type="about", URL=PlaceHasAddress$webPage[j]);
PlaceHasWebPage <-cbind (a,b) ;  # make one table from two.
Address <- data.frame(uid=PlaceHasAddress[,3:7]) 
PlaceHasAddress <- c(Place.name,Address.poBox)

# Meeting Object Definitions for RoundTable
'{ "ID": 66501, "label":"IYS 1. Status of Salmon",    			"description": "Understand the present status of salmon and their environments.",   "tagTypeID": 67011},' +      
'{ "ID": 66502, "label":"IYS 2. Salmon in a Changing Salmosphere",    			"description": "Understand and quantify the effects of natural environmental variability and man-made factors affecting salmon distribution and abundance and make projections of their future changes",   "tagTypeID": 67011},' +      


where "tagTypeID": 67011  is 

				'{ "ID": "67011",  "ideaNodeTypeID":'+ideaNodeTypeID_tag+', "label": "IYS Theme", 		"name_plural": "",  		"name_singular": "",  	"description": "", 		"status": "active", "detail_webpage": ""}'+


keywords — label, description, tagTypeID

The structure for the Idea_hasTagEdges_text = '{"Idea_hasTagEdges": [‘+

"ID": 79001,  
"fromIdeaNodeID":"6067182960”, 
"fromIdeaNodeTypeID":'+ideaNodeTypeID_tag+’, 
"fromIdeaNodeSubTypeID":"”, 
"toIdeaNodeID":"66501”, 
"toIdeaNodeTypeID":'+ideaNodeTypeID_tag+’, 
"toIdeaNodeSubTypeID":"”, 
"ideaLinkTypeID":'+ideaLinkTypeID_hasTag+', 	
“ideaLinkSubTypeID”:”", 
"label":"”, 
"description": "”,  
"status": "active”,  
"startDate":"”, 
"endDate":""  
			']}';   



# Start Neo4jDatabase
The Neo4j database process must be **started** from Applications or LaunchPad.
The error messages from Neo4j are cryptic. The following means "You forgot to start Neo4j."

>Error in stop_for_content_type(req, expected = "application/atom+xml; charset=UTF-8") : 
  Expected content-type:
application/atom+xml; charset=UTF-8
Actual content-type:
text/html; charset=UTF-8

Within R The default database *graph* is **opened**  at the default location:
> /Users/Scott2/Documents/Neo4j/default.graphdb.
    username="neo4j", password="GaB-EX8-Rbx-Ny7")
    

Remove authentication to more easily start a knowledge graph in R, **as I did**:  
1. find file: /Users/Scott2/Documents/Neo4j/.neo4j.conf  
   use command-shift-. to see hidden files (obscure Mac trick)
2. find line: dbms.security.auth_enabled=true
3. edit "true" to be "false"

I actually started Neo4j at 
> /Users/Scott2/Documents/Neo4j/salmosphere.graphdb.

This did not require changing the following URL to "open" the knowledge graph inside of R. 

```{r openDB}
# graph = startGraph("http://localhost:7474/db/data/",username="neo4j", password="GaB-EX8-Rbx-Ny7")

graph = startGraph("bolt://localhost:7687",username="neo4j", password="tumult-chunky-penates-dory-tiny-bistate")

```
This next chunk deletes the previous version of your database (but not neo4j app).
If there is a previous db, you will need to respond "Y" in the Rstudio console to permit this. 

```{r clearDB, message=TRUE}
#clear(graph) # else old graph persists. answer with capital Y
```

# Load the Knowledge Graph
## Constraints
Preventing duplication of nodes is enforce by *addConstraint* where the key is some field in the node that will be unique, such as an email. Note that two people can have the same name (but not email), so we **will** need to add a unique identifier to Person to ensure uniqueness and enable constraint (e.g. email for a specific person).  I used rneo4j::addConstraint, a function that is the equivalent of the Cypher query:
>CREATE CONSTRAINT ON (p:Person)
       ASSERT p.name IS UNIQUE

```{r constrain,message=TRUE}
# prevent duplication of nodes
addConstraint(graph, label="Person",         key="name")
addConstraint(graph, label="Place",          key="name")
addConstraint(graph, label="Activity",       key="nameShort")
addConstraint(graph, label="Organization",   key="nameShort")
addConstraint(graph, label="ContactService", key="email")
getConstraint(graph) # all
```

## Person Has ContactService 
To avoid duplicating nodes, I created the nodes first, along with links to nodes that are unique to a new node, e.g. Person has contactService. Subsequently I MATCH existing nodes to create relationships. This has the advantage of using rNeo4j syntax which is simpler than Cypher queries.
```{r Person}
# Person has ContactService
for(j in 1:dim(Person)){  # 367
    p <- createNode(graph,"Person", 
        name=Person[j,"Person.name"], 
        firstName=Person[j,"Person.firstName"],
        lastName=Person[j,"Person.lastName"] );
    e <- createNode(graph,"ContactService", 
        email = PersonHasContactService[j,"emailWork"],
        phone = PersonHasContactService[j,"phoneWork"] );
    createRel(p,"hasContactService", e)
}
```
## Activity 
```{r activity}
for(j in 1:dim(Activity)){  # 90
    p <- createNode(graph,"Activity", 
        name=Activity[j,"Activity.name"], 
        description=Activity[j,"Activity.description"]);
}    
```

##PersonHasActivity
### Read Edited
Person Has Activity was hand-edited in the Google Sheet named  
"TEMPLATE Additions to Knowledge Graph 2018 March"  
in the sheet named "PersonHasActivity"  
https://docs.google.com/spreadsheets/d/1X0ZHxVPLdt2wwFdJB_j0jn3vB_pNsvqodKlHtu2p81Q/edit?usp=sharing
This has zero security,"published to the web."

```{r gs7}
ss7 <- gs_key("1X0ZHxVPLdt2wwFdJB_j0jn3vB_pNsvqodKlHtu2p81Q")
# IYS Row
PersonHasActivity1 = gs_read(ss7,ws="PersonHasActivity")  %>% as.data.frame()
# unmess. 1 extra row at top, 2 extra columns on right
PersonHasActivity1 <-PersonHasActivity1[-1,1:2]
colnames(PersonHasActivity1) <- c("Activity.nameShort",
    "Person.name")
PersonHasActivity1[1,]
```

### Create Links
Neo4j tells me "Only directed relationships are supported in CREATE." However **(n)--(m)** is a valid pattern to find a link in either direction between nodes n and m. 

The following query is applied many times in the next chunk of R code. 
>MERGE (p:Person{name:"First Last"}) 
 MERGE (a:Activity{nameShort:"Some Activity"})
 CREATE (p) -[:hasActivity]-> (a) 
 RETURN p.name,a.nameShort 
 
*Added 2 labels, created 2 nodes, set 2 properties, created 1 relationship, started streaming 1 records after 22 ms and completed after 22 ms.* 

This is relatively slow way to load the knowledge graph (45 s^-1). Some buffer for queries is implied because the queries are generated much faster.

```{r}
for(j in 1:dim(PersonHasActivity1)[1]){  # I used j=1 for testing
    query <- paste0(
'MERGE (p:Person{name:"',PersonHasActivity1$Person.name[j],'"}) 
 MERGE (a:Activity{nameShort:"',PersonHasActivity1$Activity.nameShort[j],'"})
 CREATE (p) -[:hasActivity]-> (a) 
 RETURN p.name,a.nameShort ')
    cypher(graph,query)    
}
```

This added new Person nodes (perhaps including misspelt duplication) resulting in 461 Person.
### Frequency of Activity per Person
How many of **Person** have 1, 2, or 3 links to an **Activity**? The Cypher function *size()* counts links. Here is the resulting distribution of Activity per Person. Almost two thirds of Person nodes are linked to zero Activity (yet), but 24% are linked to one Activity and 12% to two or more (one Person has seven Activity).
```{r PhA}
query <- 'MATCH (p:Person) RETURN size( (p)-[:hasActivity]->() )'
cypher(graph,query) %>% table %>% `/`(461/100) %>% round(1) %>%
    kable(col.names=c("Links","%"),caption="Density of Activities per Person (461 cases)")
```

## Idea
Many (more than 124 out of 163) survey respondents are linked to many **Idea** nodes representing the 37 IYS topics because they indicated those topics were something they needed, offered, or thought to be critical. 
>(:Person) -[:hasIdea]-> (:Idea) 
Those 37 **Idea** nodes are linked to 6 more **Idea** nodes representing the IYS themes: **Idea hasIdea Idea**. Additional **Idea** nodes "Other" IYS topics were proffered, each is a new **Idea** linked to a **Person**.

Separtely from the IYS topics, the survey asked for key words associated with each **Activity**, creating another set of **Idea** nodes with links
>(:Activity) -[:hasIdea]-> (:Idea) 

The result is that two separate **Person** can, in theory be linked through concepts associated with their separate projects:
>(:Person) -[:hasActivity]--[:hasIdea]- (:Idea) -[:hasIdea]- (:Activity) - (:Person)

However few of the orginal key words are found in more than one **Activity**. 

```{r iysIdea}
# IYS topics (37) and themes (6)
n=dim(IdeaTag)[1]
for(j in 1:n) createNode(graph,"Idea",
    name=IdeaTag.name[j,1], description=IdeaTag.name[j,2] );

# Activity key words
n=dim(IdeaTagA)[1]
for(j in 1:n) createNode(graph,"Idea",
    name=IdeaTagA.name[j,1], description=IdeaTagA.name[j,2] );
```
### Idea Has Idea
```{r II}
# link IYS topic to IYS theme
n=dim(IdeaTagHasIdeaTag)[1];
for(j in 1:n){
    query=paste0(
    'MATCH (i1:Idea{name:"',IdeaTagHasIdeaTag[j,1],'"})
     MATCH (i2:Idea{name:"',IdeaTagHasIdeaTag[j,2],'"})
     CREATE (i1) -[:hasIdea]-> (i2)');
    cypher(graph,query)
}
```
### Activity Has Idea
```{r AI}
# colnames(ActivityHasIdeaTag) # "X" "Activity.name" "IdeaTag.name"
n=dim(ActivityHasIdeaTag)[1];
for(j in 1:n){
    query=paste0(
    'MATCH (a:Activity{name:"',ActivityHasIdeaTag[j,2],'"})
     MATCH (b:Idea{name:"',    ActivityHasIdeaTag[j,3],'"})
    CREATE (a) -[:hasIdea]-> (b)');
    cypher(graph,query)
}

 
    
'MERGE (p:Person{name:"',PersonHasActivity1$Person.name[j],'"}) 
 MERGE (a:Activity{nameShort:"',PersonHasActivity1$Activity.nameShort[j],'"})
 CREATE (p) -[:hasActivity]-> (a) 
 RETURN p.name,a.nameShort ')
    cypher(graph,query)    
```



# DFO Region
a = unique(placeAddress$region)
for(j in 1:length(a)){
    createNode(graph,"Organization",type="DFO Region", name=a[j])
}
# Place has Address
for(j in 1:length(placeAddress)){
    pl <- createNode(graph,"Place",
        name=placeAddress[j,"place"],
        latLong=placeAddress[j,"latLong"],
        photo=placeAddress[j,"photo"],
        webPage=placeAddress[j,"webPage"]);
    ad <- createNode(graph,"Address", 
        poBox=placeAddress[j,"poBox"],
        address=placeAddress[j,"address"],
        city=placeAddress[j,"city"],
        province=placeAddress[j,"province"],
        postalCode=placeAddress[j,"postalCode"] )
    createRel(pl,"hasAddress",ad)
```


### Person with Unique Links 
Create the Person nodes one by one, and, upon creation, link them to other nodes which are not a list. E.g. email is unique to each person, so

>CREATE (p:Person{name:""})
WITH p
CREATE (p) -[hasContactService]- (ContactService{email:""}) 

Similarly, each Person has one Place (so far) but each Place can have more than one Person, and also (:Place{name:""} has a constraint that prevents any new Place from having the same name as an existing Place (uniqueness). This prevents duplicating nodes. 

>MERGE (p) -[hasPlace{type:"building"}]- (:Place{name:""})


```{r personHasOne}
nr <- dim(survey1)[1]
for(j in 1:nr){
query=paste0('CREATE (p:Person{name:"',
survey1[j,"name"],
'", firstName:"',
survey1[j,"firstName"],
'", lastName:"',
survey1[j,"lastName"],
'"}) WITH p 
MERGE (p) -[:hasOrganization{jobTitle:"',
survey1[j,"jobTitle"],
'",jobCode:"',
survey1[j,"jobCode"], 
'",jobDescription:"',
survey1[j,"jobDescription"],
'",jobChain:"',
survey1[j,"branchDirectorateSector"],
'"}]-> (:Organization {name:"',
survey1[j,"region"],
'"}) MERGE (p) -[:hasPlace{type:"building"}]->(:Place{name:"',
survey1[j,"place"],
'"}) CREATE (p) -[:hasContactService]-> (:ContactService {email:"',
survey1[j,"email"], 
'"})' 
) # end paste
# query 
cypher(graph,query)
} # end loop
```
### Samples of Nodes
Random samples to check that nodes are as expeted.
```{r sampleNodes}
a <- cypher(graph,'MATCH (p:Person) RETURN p.name');
SampleRows(a, "Sample of (:Person)")
cat("Found",dim(a)[1],"of which", sum(is.na(a[,1]))," are not NA\n")
a <- cypher(graph,'MATCH (p:ContactService) RETURN p.email');
SampleRows(a, "Sample of (:ContactService)")
cat("Found",dim(a)[1],"of which", sum(is.na(a[,1]))," are not NA\n")
a <- cypher(graph,'MATCH (p:Place) RETURN p.name');
SampleRows(a,  "Sample of (:Place)")
cat("Found",dim(a)[1],"of which", sum(is.na(a[,1]))," are not NA\n")
a <- cypher(graph,'MATCH (p:Organization) RETURN p.name');
SampleRows(a, "Sample of (:Organization)")
cat("Found",dim(a)[1],"of which", sum(is.na(a[,1]))," are not NA\n")
```

### Person Has Lists
Some of the survey data are lists. E.g. *webPage* can be a comma-separated list such as
>http://www.pac.dfo-mpo.gc.ca/sep-pmvs/index-eng.html, https://www.psf.ca/what-we-do/community-salmon-program, http://dfo-mpo.gc.ca/oceans/crf-frc/index-eng.html, http://www.dfo-mpo.gc.ca/pnw-ppe/rfcpp-ppcpr/index-eng.html,  http://fwcp.ca/

Some data are lists of list, converted by hand to quoted lists of comma-separated lists, e.g. *Activity1KeyPeople* such as
>"Wilf Luedke, Area Chief Stock Assessment, DFO, wilf.luedke@dfo-mpo.gc.ca", 
"Diana Dobson, Stock Assessment Biologist, DFO, Diana.dobson@dfo-mpo.gc.ca",
"Tawney Lem, Executive Director, West Coast Aquatic Management Association,  tawney@westcoastaquatic.ca",
"Mike Austin, Conuma Hatchery Manager, DFO, mike.austin@dfo-mpo.gc.ca"

Yet other data are lists but separated into separate fields in the survey responses, e.g. on Person can have *activity1, activity2, activity3* and each of those is a list: *Title, Description, YourRole,	WebLink, Location, KeyPeople, Keywords* and four of those can be lists. These are dealt with one Person at a time, unpacked by loops in R, and re-created in Neo4j. The survey was edited to avoid duplicate activities. Many of the links from an activity will be to previously existing nodes. Duplication of nodes is avoided by (1) constraints added to the database design, and (2) use of MERGE instead of CREATE.  

```{r personHasList}

act <- c("activity1Title","activity2Title","activity3Title")
des <- c("activity1Description","activity1Description",
         "activity1Description")

for(j in 1:nr){
    for(k in 1:3){
        if(is.na(survey1[j,act[k]])) next;
#       createNode(graph, "Activity", name = survey1[j,act[k]], 
#                              description = survey1[j,des[k]])CREATE p MATCH-[:hasActivity]-(:Activity{name:"', 
survey1[j,act[k]],
'", description:"', survey1[j,des[k]], '"})' )
        cypher(graph,query)
    }
}
a <- cypher(graph,'MATCH (a:Activity) RETURN a.name,a.description'); 
SampleRows(a,"Sample of (:Activity)") 

'"})
CREATE p -[:hasURL] ->(:URL{url:"',
survey1[j,"webPage"],


```

  
 CREATE (:Person{name:survey.person}) -[:hasContactService]-> (:ContactService {email:survey.email, phone:survey.telephone})
MERGE  (at:Place{name:survey.place})
MERGE (org3:Organization{name:survey.org3,type:"org3"})
MERGE (org2:Organization{name:survey.org2,type:"org2"})
MERGE (org1:Organization{name:survey.org1,type:"org1"})
RETURN at.name, org2.name' );

```
